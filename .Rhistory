devtools::build_vignettes()
devtools::load_all(".")
devtools::document()
devtools::build_vignettes()
devtools::load_all(".")
estimator
?estimate
library("NeuralEstimators")
library("JuliaConnectoR")
## Observed data: 100 replicates of a univariate random variable
Z = matrix(rnorm(100), nrow = 1)
## Construct the estimator
estimator <- juliaEval('
using NeuralEstimators
using Flux
p = 2    # number of parameters in the statistical model
w = 32   # number of neurons in each layer
psi = Chain(Dense(1, w, relu), Dense(w, w, relu))
phi = Chain(Dense(w, w, relu), Dense(w, p))
estimator = DeepSet(psi, phi)
')
## Apply the estimator
estimate(estimator, Z)
x <- estimate(estimator, Z)
class(x)
?juliaGet
juliaGet(x)
x[[1]]
x[[2]]
x[[3]]
as.matrix(x)
class(x)
juliaGet(x)
devtools::load_all(".")
x <- estimate(estimator, Z)
x
devtools::load_all(".")
x <- estimate(estimator, Z)
x
devtools::load_all(".")
x <- estimate(estimator, Z)
x
devtools::load_all(".")
x <- estimate(estimator, Z)
x
Z
devtools::load_all(".")
Z
x <- estimate(estimator, Z)
x
matrix(1)
devtools::load_all(".")
?bootstrap
library("NeuralEstimators")
library("JuliaConnectoR")
## Observed data: 100 replicates of a univariate random variable
Z = matrix(rnorm(100), nrow = 1)
## Construct the estimator
estimator <- juliaEval('
using NeuralEstimators
using Flux
p = 2    # number of parameters in the statistical model
w = 32   # number of neurons in each layer
psi = Chain(Dense(1, w, relu), Dense(w, w, relu))
phi = Chain(Dense(w, w, relu), Dense(w, p))
estimator = DeepSet(psi, phi)
')
bootstrap(estimator, Z = Z)
devtools::load_all(".")
bootstrap(estimator, Z = Z)
rep(1:5, each = 20)
bootstrap(estimator, Z = Z, blocks = rep(1:5, each = 20))
Z = lapply(1:B, function(b) matrix(rnorm(100), nrow = 1))
parameters <- matrix(c(0.1, 0.5), nrow = 2)
B = 400
Z = lapply(1:B, function(b) matrix(rnorm(100), nrow = 1))
bootstrap(estimator, Z = Z)
bootstrap(estimator, Z = Z, parameters = parameters)
devtools::load_all(".")
bootstrap(estimator, Z = Z)
devtools::load_all(".")
bootstrap(estimator, Z = Z)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library("NeuralEstimators")
library("JuliaConnectoR")
prior <- function(K) {
mu    <- rnorm(K)
sigma <- rgamma(K, 1)
theta <- matrix(c(mu, sigma), byrow = TRUE, ncol = K)
return(theta)
}
set.seed(1)
theta_train = prior(10000)
theta_val   = prior(1000)
theta_test  = prior(1000)
simulate <- function(theta_set, m) {
apply(theta_set, 2, function(theta) {
Z <- rnorm(m, theta[1], theta[2])
dim(Z) <- c(1, m)
Z
}, simplify = FALSE)
}
m <- 15
Z_train <- simulate(theta_train, m)
Z_val   <- simulate(theta_val, m)
estimator <- juliaEval('
using NeuralEstimators
using Flux
p = 2    # number of parameters in the statistical model
w = 32   # number of neurons in each layer
psi = Chain(Dense(1, w, relu), Dense(w, w, relu))
phi = Chain(Dense(w, w, relu), Dense(w, p))
estimator = DeepSet(psi, phi)
')
estimator <- train(
estimator,
theta_train = theta_train,
theta_val   = theta_val,
Z_train = Z_train,
Z_val   = Z_val,
epochs = 30
)
Z_test <- simulate(theta_test, m)
assessment <- assess(estimator, theta_test, Z_test)
assessment
Z_test <- simulate(theta_test, m)
assessment <- assess(estimator, theta_test, Z_test)
# Generate some "observed" data
theta <- as.matrix(c(0, 0.5))    # true parameters
Z     <- simulate(theta, m)      # pretend that this is observed data
# Estimates and bootstrap-based credible intervals
estimate(estimator, Z)         # point estimates from the observed data
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library("NeuralEstimators")
library("JuliaConnectoR")
prior <- function(K) {
mu    <- rnorm(K)
sigma <- rgamma(K, 1)
theta <- matrix(c(mu, sigma), byrow = TRUE, ncol = K)
return(theta)
}
set.seed(1)
theta_train = prior(10000)
theta_val   = prior(1000)
theta_test  = prior(1000)
simulate <- function(theta_set, m) {
apply(theta_set, 2, function(theta) {
Z <- rnorm(m, theta[1], theta[2])
dim(Z) <- c(1, m)
Z
}, simplify = FALSE)
}
m <- 15
Z_train <- simulate(theta_train, m)
Z_val   <- simulate(theta_val, m)
estimator <- juliaEval('
using NeuralEstimators
using Flux
p = 2    # number of parameters in the statistical model
w = 32   # number of neurons in each layer
psi = Chain(Dense(1, w, relu), Dense(w, w, relu))
phi = Chain(Dense(w, w, relu), Dense(w, p))
estimator = DeepSet(psi, phi)
')
estimator <- train(
estimator,
theta_train = theta_train,
theta_val   = theta_val,
Z_train = Z_train,
Z_val   = Z_val,
epochs = 30
)
devtools::load_all(".")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library("NeuralEstimators")
library("JuliaConnectoR")
prior <- function(K) {
mu    <- rnorm(K)
sigma <- rgamma(K, 1)
theta <- matrix(c(mu, sigma), byrow = TRUE, ncol = K)
return(theta)
}
set.seed(1)
theta_train = prior(10000)
theta_val   = prior(1000)
theta_test  = prior(1000)
simulate <- function(theta_set, m) {
apply(theta_set, 2, function(theta) {
Z <- rnorm(m, theta[1], theta[2])
dim(Z) <- c(1, m)
Z
}, simplify = FALSE)
}
m <- 15
Z_train <- simulate(theta_train, m)
Z_val   <- simulate(theta_val, m)
estimator <- juliaEval('
using NeuralEstimators
using Flux
p = 2    # number of parameters in the statistical model
w = 32   # number of neurons in each layer
psi = Chain(Dense(1, w, relu), Dense(w, w, relu))
phi = Chain(Dense(w, w, relu), Dense(w, p))
estimator = DeepSet(psi, phi)
')
estimator <- train(
estimator,
theta_train = theta_train,
theta_val   = theta_val,
Z_train = Z_train,
Z_val   = Z_val,
epochs = 30
)
Z_test <- simulate(theta_test, m)
assessment <- assess(estimator, theta_test, Z_test)
head(assessment$estimates)
J     <- 100
theta <- as.matrix(c(0, 0.5))
Z     <- lapply(1:J, function(i) simulate(theta, m))
Z     <- do.call(c, Z)
assessment <- assess(estimator, theta, Z)
parameter_labels <- c("θ1" = expression(mu), "θ2" = expression(sigma))
plotdistribution(assessment$estimates, type = "scatter", parameter_labels = parameter_labels)
# Generate some "observed" data
theta <- as.matrix(c(0, 0.5))    # true parameters
Z     <- simulate(theta, m)      # pretend that this is observed data
# Estimates and bootstrap-based credible intervals
estimate(estimator, Z)         # point estimates from the observed data
Z
devtools::load_all(".")
i
# Estimates and bootstrap-based credible intervals
estimate(estimator, Z)         # point estimates from the observed data
bs <- bootstrap(estimator, Z)  # non-parametric bootstrap estimates
bs
confidenceinterval(bs)
head(bs)
bs[, 1:6]
devtools::build_vignettes()
suppressMessages({
library("INLA")
library("ngme2")
library("rSPDE")
library("fields")
})
mesh = inla.mesh.create(
lattice = inla.mesh.lattice(
x = seq(0, 1, length.out = 100),
y = seq(0,1,length.out = 100)
),
extend = FALSE, refine = FALSE
)
fem  <- inla.mesh.fem(mesh)
simulate <- function(fem, loc, range, smooth) {
h <- diag(fem$c0)
op <- matern.operators(
range = range,
sigma = 1,
nu = smooth,
mesh = mesh,
type = "operator",
parameterization = "matern"
)
W = rnig(n = length(h), delta = -10, mu = 10, nu = 100, sigma = 1, h = h)
Y = as.vector(Pl.solve(op, Pr.mult(op, W)))
proj = inla.mesh.projector(mesh, loc = loc)
Z = inla.mesh.project(proj, Y)
return(Z)
}
# Example:
n   <- 250
loc <- cbind(x = runif(n), y = runif(n))
Z   <- simulate(fem, loc, range = 0.2, smooth = 0.7)
df  <- data.frame(Z = Z, x = loc[, 1], y = loc[, 2])
ggplot(df) +
geom_point(aes(x = x, y = y, colour = Z)) +
scale_color_distiller(palette = "Spectral") +
theme_bw() + coord_fixed()
library("ggplot2")
# Example:
n   <- 250
loc <- cbind(x = runif(n), y = runif(n))
Z   <- simulate(fem, loc, range = 0.2, smooth = 0.7)
df  <- data.frame(Z = Z, x = loc[, 1], y = loc[, 2])
ggplot(df) +
geom_point(aes(x = x, y = y, colour = Z)) +
scale_color_distiller(palette = "Spectral") +
theme_bw() + coord_fixed()
# Example:
n   <- 250
loc <- cbind(x = runif(n), y = runif(n))
Z   <- simulate(fem, loc, range = 0.2, smooth = 0.7)
df  <- data.frame(Z = Z, x = loc[, 1], y = loc[, 2])
ggplot(df) +
geom_point(aes(x = x, y = y, colour = Z)) +
scale_color_distiller(palette = "Spectral") +
theme_bw() + coord_fixed()
# Example:
n   <- 250
loc <- cbind(x = runif(n), y = runif(n))
Z   <- simulate(fem, loc, range = 0.2, smooth = 0.7)
df  <- data.frame(Z = Z, x = loc[, 1], y = loc[, 2])
ggplot(df) +
geom_point(aes(x = x, y = y, colour = Z)) +
scale_color_distiller(palette = "Spectral") +
theme_bw() + coord_fixed()
?rnig
mesh = inla.mesh.create(
lattice = inla.mesh.lattice(
x = seq(0, 1, length.out = 100),
y = seq(0,1,length.out = 100)
),
extend = FALSE, refine = FALSE
)
fem  <- inla.mesh.fem(mesh)
simulate <- function(fem, loc, range, smooth) {
h <- diag(fem$c0)
op <- matern.operators(
range = range,
sigma = 1,
nu = smooth,
mesh = mesh,
type = "operator",
parameterization = "matern"
)
W = rnig(n = length(h), delta = -10, mu = 10, nu = 100, sigma = 1)#, h = h)
Y = as.vector(Pl.solve(op, Pr.mult(op, W)))
proj = inla.mesh.projector(mesh, loc = loc)
Z = inla.mesh.project(proj, Y)
return(Z)
}
# Example:
n   <- 250
loc <- cbind(x = runif(n), y = runif(n))
Z   <- simulate(fem, loc, range = 0.2, smooth = 0.7)
df  <- data.frame(Z = Z, x = loc[, 1], y = loc[, 2])
ggplot(df) +
geom_point(aes(x = x, y = y, colour = Z)) +
scale_color_distiller(palette = "Spectral") +
theme_bw() + coord_fixed()
# TODO make a grid of plots that shows realisations from the model (show the
# process as a completely observed field, not over the observed locations)
diag(fem$c0)
?inla.mesh.fem
diag(fem$c0),
diag(fem$c0)
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::load_all(".")
devtools::build_vignettes()
devtools::build_vignettes()
?rgamma
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::load_all(".")
devtools::build_vignettes()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library("NeuralEstimators")
library("JuliaConnectoR")
prior <- function(K) {
mu    <- rnorm(K)
sigma <- rgamma(K, 1)
theta <- matrix(c(mu, sigma), byrow = TRUE, ncol = K)
return(theta)
}
set.seed(1)
theta_train = prior(10000)
theta_val   = prior(1000)
theta_test  = prior(1000)
simulate <- function(theta_set, m) {
apply(theta_set, 2, function(theta) {
Z <- rnorm(m, theta[1], theta[2])
dim(Z) <- c(1, m)
Z
}, simplify = FALSE)
}
m <- 15
Z_train <- simulate(theta_train, m)
Z_val   <- simulate(theta_val, m)
estimator <- juliaEval('
using NeuralEstimators
using Flux
p = 2    # number of parameters in the statistical model
w = 32   # number of neurons in each layer
psi = Chain(Dense(1, w, relu), Dense(w, w, relu))
phi = Chain(Dense(w, w, relu), Dense(w, p))
estimator = DeepSet(psi, phi)
')
estimator <- train(
estimator,
theta_train = theta_train,
theta_val   = theta_val,
Z_train = Z_train,
Z_val   = Z_val,
epochs = 30
)
devtools::load_all(".")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library("NeuralEstimators")
library("JuliaConnectoR")
prior <- function(K) {
mu    <- rnorm(K)
sigma <- rgamma(K, 1)
theta <- matrix(c(mu, sigma), byrow = TRUE, ncol = K)
return(theta)
}
set.seed(1)
theta_train = prior(10000)
theta_val   = prior(1000)
theta_test  = prior(1000)
simulate <- function(theta_set, m) {
apply(theta_set, 2, function(theta) {
Z <- rnorm(m, theta[1], theta[2])
dim(Z) <- c(1, m)
Z
}, simplify = FALSE)
}
m <- 15
Z_train <- simulate(theta_train, m)
Z_val   <- simulate(theta_val, m)
estimator <- juliaEval('
using NeuralEstimators
using Flux
p = 2    # number of parameters in the statistical model
w = 32   # number of neurons in each layer
psi = Chain(Dense(1, w, relu), Dense(w, w, relu))
phi = Chain(Dense(w, w, relu), Dense(w, p))
estimator = DeepSet(psi, phi)
')
estimator <- train(
estimator,
theta_train = theta_train,
theta_val   = theta_val,
Z_train = Z_train,
Z_val   = Z_val,
epochs = 30
)
Z_test <- simulate(theta_test, m)
assessment <- assess(estimator, theta_test, Z_test)
head(assessment$estimates)
J     <- 100
theta <- as.matrix(c(0, 0.5))
Z     <- lapply(1:J, function(i) simulate(theta, m))
Z     <- do.call(c, Z)
assessment <- assess(estimator, theta, Z)
parameter_labels <- c("θ1" = expression(mu), "θ2" = expression(sigma))
plotdistribution(assessment$estimates, type = "scatter", parameter_labels = parameter_labels)
marginal <- plotdistribution(assessment$estimates, type = "box", parameter_labels = parameter_labels)
marginal
library("cowplot")
library("ggpubr")
ggarrange(joint, marginal)
joint <- plotdistribution(assessment$estimates, type = "scatter", parameter_labels = parameter_labels)
ggarrange(joint[[1]], marginal)
library("cowplot")
ggarrange(joint[[1]], marginal)
cowplot::ggarrange(joint[[1]], marginal)
?cowplot
?plotdistribution
marginal <- plotdistribution(assessment$estimates, type = "box", parameter_labels = parameter_labels, return_list = TRUE)
marginal
joint
ggarrange(plots = c(joint, marginal))
ggarrange(plotlist = c(joint, marginal))
ggarrange(plotlist = c(joint, marginal), nrow = 1)
ggarrange(plotlist = c(joint, marginal), nrow = 1, common.legend = TRUE)
ggarrange(plotlist = c(joint, marginal), nrow = 1, common.legend = TRUE)
devtools::build_vignettes()
devtools::build_vignettes()
devtools::build_vignettes()
devtools::load_all(".")
?citation
citation("NeuralEstimators")
citation("NeuralEstimators")
citation("NeuralEstimators")
citation("NeuralEstimators")
citation("NeuralEstimators")
citation("NeuralEstimators")
usethis::use_test("core")
?train
usethis::use_test("plot")
?test_that
library(testthat)
devtools::load_all(".")
devtools::load_all(".")
usethis::use_github_action("check-standard")
usethis::use_github_action("test-coverage")
devtools::install_github("MattSainsbury-Dale/NeuralEstimatorsR")
devtools::install_github("msainsburydale/NeuralEstimators")
devtools::install_github("msainsburydale/NeuralEstimators")
